// Copyright 2018, Cristi√°n Donoso.
// This code has a BSD license. See LICENSE.

#include "warhol/platform/platform.h"

// For some reason it needs to be defined at the end.
#include <windows.h>

namespace warhol {

std::string GetCurrentExecutablePath() {
  // Get the executable handle.
  HMODULE exe_module = GetModuleHandleA(NULL);
  char path[MAX_PATH];
  GetModuleFileName(exe_module, path, MAX_PATH);

  return path;
}

std::string GetCurrentExecutableDirectory() {
  std::string exe_path = GetCurrentExecutablePath();
  size_t separator = exe_path.rfind('\\');
  if (separator == std::string::npos)
    return exe_path;
  return exe_path.substr(0, separator);
}

std::string GetBasePath() {
  std::string exe_path = GetCurrentExecutablePath();
  // First search for a last '/' (path probably generated by Warhol itself).
  // If not, see if it's a normal Windows path.
  size_t separator = exe_path.rfind('\\');
  if (separator == std::string::npos)
    separator = exe_path.rfind('\\');

  if (separator == std::string::npos)
    return exe_path;
  auto base_path = exe_path.substr(0, separator);
  return PathJoin({std::move(base_path), ".."});
}

// GetNanoseconds --------------------------------------------------------------

namespace {

uint64_t GetHighPerformaceCounter() {
  LARGE_INTEGER counter;
  QueryPerformanceCounter(&counter);
  return (uint64_t)counter.QuadPart;
}

uint64_t GetHighPerformaceFrequency() {
  LARGE_INTEGER frequency;
  QueryPerformanceFrequency(&frequency);
  return (uint64_t)frequency.QuadPart;
}

thread_local uint64_t last_counter = GetHighPerformaceCounter();

}  // namespace

uint64_t GetNanoseconds() {
  uint64_t now = GetHighPerformaceCounter();
  uint64_t diff = now - last_counter;

  // ddiff is in seconds.
  double ddiff = (double)diff / (double)GetHighPerformaceFrequency();
  ddiff *= 1000000000;
  return (uint64_t)ddiff;
}

}  // namespace warhol
